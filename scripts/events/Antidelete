const axios = require('axios');
const fs = require('fs-extra');
const path = require('path');

module.exports.config = {
    name: "antidelete",
    eventType: ["message", "message_reply", "message_unsend"], // On Ã©coute tout : rÃ©ception et suppression
    version: "1.0",
    credits: "Joel",
    description: "DÃ©tecte les messages supprimÃ©s et les envoie dans un groupe d'archives."
};

// CrÃ©ation d'une mÃ©moire temporaire globale pour stocker les messages rÃ©cents
if (!global.messageCache) {
    global.messageCache = new Map();
}

module.exports.onEvent = async function ({ api, event }) {
    const ADMIN_THREAD_ID = "1796368234344694"; // Ton groupe de sauvegarde

    // 1. SAUVEGARDE (Quand quelqu'un envoie un message)
    if (event.type === "message" || event.type === "message_reply") {
        // On garde le message en mÃ©moire
        global.messageCache.set(event.messageID, {
            body: event.body,
            senderID: event.senderID,
            attachments: event.attachments || [],
            timestamp: Date.now()
        });

        // Nettoyage : Si la mÃ©moire est trop pleine (+1000 msgs), on supprime les vieux
        if (global.messageCache.size > 1000) {
            const oldestKey = global.messageCache.keys().next().value;
            global.messageCache.delete(oldestKey);
        }
    }

    // 2. DÃ‰TECTION (Quand quelqu'un supprime un message)
    if (event.type === "message_unsend") {
        const deletedID = event.messageID;

        // On vÃ©rifie si on a le message en mÃ©moire
        if (global.messageCache.has(deletedID)) {
            const msg = global.messageCache.get(deletedID);
            
            // On rÃ©cupÃ¨re le nom de celui qui a supprimÃ©
            let name = "Utilisateur inconnu";
            try {
                const userInfo = await api.getUserInfo(msg.senderID);
                name = userInfo[msg.senderID].name;
            } catch (e) {
                name = msg.senderID;
            }

            // Construction du rapport
            let report = `ğŸ—‘ï¸ **MESSAGE SUPPRIMÃ‰ DÃ‰TECTÃ‰**\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
            report += `ğŸ‘¤ **Auteur :** ${name}\n`;
            report += `ğŸ“ **Groupe ID :** ${event.threadID}\n`;
            report += `ğŸ•’ **Date :** ${new Date().toLocaleString()}\n`;
            report += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
            report += `ğŸ“ **Contenu :**\n${msg.body || "(Aucun texte)"}`;

            // Gestion des piÃ¨ces jointes (Photos, VidÃ©os...)
            const attachments = [];
            if (msg.attachments.length > 0) {
                report += `\n\nğŸ“ **PiÃ¨ces jointes :** ${msg.attachments.length} fichier(s).`;
                
                // On essaie de rÃ©cupÃ©rer les fichiers
                for (let i = 0; i < msg.attachments.length; i++) {
                    const attach = msg.attachments[i];
                    try {
                        const url = attach.url;
                        const ext = attach.type === "photo" ? ".jpg" : 
                                   attach.type === "video" ? ".mp4" : 
                                   attach.type === "audio" ? ".mp3" : ".bin";
                        
                        const fileName = `del_${deletedID}_${i}${ext}`;
                        const filePath = path.join(__dirname, 'cache', fileName);

                        // CrÃ©ation dossier cache si nÃ©cessaire
                        if (!fs.existsSync(path.dirname(filePath))) fs.mkdirSync(path.dirname(filePath), { recursive: true });

                        const res = await axios.get(url, { responseType: 'arraybuffer' });
                        fs.writeFileSync(filePath, Buffer.from(res.data));
                        attachments.push(fs.createReadStream(filePath));
                    } catch (e) {
                        report += `\nâŒ (Erreur rÃ©cup fichier ${i+1})`;
                    }
                }
            }

            // Envoi vers le groupe ADMIN (1796368234344694)
            const msgData = {
                body: report,
                attachment: attachments
            };

            api.sendMessage(msgData, ADMIN_THREAD_ID, () => {
                // Nettoyage des fichiers temporaires aprÃ¨s envoi
                attachments.forEach(stream => {
                    try { fs.unlinkSync(stream.path); } catch(e) {}
                });
            });
        }
    }
};
